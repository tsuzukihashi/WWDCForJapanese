import Foundation

struct MeetPasskeys: ArticleProtocol {
    var id: String {
        UUID().uuidString
    }

    var title: String {
        "Meet passkeys"
    }

    var imageUrl: URL {
        URL(string: "https://devimages-cdn.apple.com/wwdc-services/images/124/6586/6586_wide_250x141_2x.jpg")!
    }

    var link: URL {
        URL(string: "https://developer.apple.com/videos/play/wwdc2022/10092/")!
    }

    var english: String {
        """
        Hi, I'm Garrett, an engineer on the Authentication Experience team.
         And in this video, I'm excited to talk about passkeys, a next-generation authentication technology.
         But first, I need to talk about today's authentication technology: passwords.
         You're probably used to signing in to nearly every app and website with them.
         Passwords are really hard to use securely.
         All of us know we're supposed to create strong, unique passwords for every account, but not many people actually do.
         As you're designing your apps and websites, there's this constant tradeoff between keeping accounts secure and designing a good experience.
         And even if your apps and websites do everything right, issues like phishing and password reuse can still lead to account compromise.
         In macOS Monterey and iOS 15, we announced a developer preview of the solution -- passkeys -- and got so much great feedback.
         In macOS Ventura and iOS 16, we're excited to make passkeys available to everyone.
         Now is the time to adopt them.
         With passkeys, not only is the user experience better than a password, but also entire categories of security problems, like weak and reused credentials, credential leaks, and phishing, are just not possible anymore.
         And they're so easy to use.
         Let me show you.
         Let's start with our favorite demo app, Shiny.
         This app lets me see one cute picture a day and has a typical password-based sign-in flow.
         I can tap in the user name field and see an AutoFill suggestion for my account.
         I'll select that, sign in.
         Then, I can fill in my password.
        Then, I wait around for a little bit until an SMS message comes in with my one-time code.
        There it is.
         And eventually, I'm signed in.
         It took a few steps, but with the help of AutoFill and my password manager, I was able to get there.
        Now that I'm signed in, I'll add a passkey to this account.
         Account Management, Add passkey.
         Here, I get the system sheet for creating a passkey.
         Continue.
         Done! In just a few taps, my device has generated a unique, cryptographically strong key pair for my account and stored it in my iCloud Keychain, so it will sync and work across all of my devices running macOS Ventura and iOS 16.
        Now that I have a passkey, let me show you how easy it is to use.
         I'm going to sign out, and I'm back at the same sign-in form I used earlier.
         I'm going to focus the user name field like before.
         Now that I have a passkey saved for my account, it shows up in the QuickType bar.
         All I have to do is tap it and I'm signed in.
         One step.
         When saving the passkey, I didn't have to come up with a new password or try to satisfy any complexity requirements.
         Each passkey is generated by the system and guaranteed to be strong and only ever used for a single account.
         And when I'm signing in with it, it can be shown in the existing sign-in flows I'm used to, and it's a single tap to use.
         And the system will take care of only letting me use it in the correct app or website, with strong built-in phishing resistance.
         Of course, passkeys work on the web too.
         Here I am on Shiny's website in Safari.
         Just like on my phone, when I focus the user name field, my passkey is already there and ready to use, thanks to iCloud Keychain.
         All I have to do is Touch ID and I'm signed in.
         That's it.
         Apple's passkey implementation is built on open standards.
         We've been working with other platform vendors within the FIDO Alliance to make sure that passkey implementations are compatible cross-platform and can work on as many devices as possible.
         After upgrading my account to use a passkey, I'm still able to sign in to it on my friend's PC.
         Of course, my friend's PC doesn't have the passkey saved locally, but I can still type my user name here.
         When I press Sign In, I get a sheet that's offering to let me use my phone.
         Then I get a QR code.
         Let me scan that.
        My phone recognizes that this QR code is for signing in with a passkey.
         When I select this option, my phone and the browser securely connect to each other.
         Now I can just Continue, and I'm signed in.
         This cross-platform sign-in experience is a first-class system feature that's part of the standards behind passkeys.
         On the surface, it appears incredibly simple, but this is not just a QR code.
         Behind the scenes, the devices are performing a local key agreement, proving proximity, establishing an end-to-end encrypted communication channel, all to let you sign in in a way that's easy but maintains the strong phishing resistance of passkeys.
         It works great for allowing me to sign in securely to my account on any device.
         Another important feature for a password replacement is the ability to share accounts between two or more people.
         To share a passkey with someone else, I can use AirDrop.
        My partner and I also have an account for Shiny that we share, which I've already upgraded to use a passkey.
         With a passkey, the credential isn't something I could type, but I'm still able to share it with people I trust.
         On my phone, I'll open up the account details.
        Here are all of my accounts, which use both passwords and passkeys.
         I can tap on our shared account to pull up more details.
         Here, I can get some information about my saved passkey or add a note to this account.
         I can also share my passkey.
         There's my partner's phone.
         I'll go ahead and select that.
        Now my partner has the passkey too.
        And that's how easy it is to use passkeys everywhere.
         I've just gone over the experience of using a passkey.
         Next, I'll talk about what a passkey is and some interface guidelines when using them.
         Then I'll show you how you can integrate passkeys into your existing sign-in flows in your apps and websites, by taking advantage of AutoFill, followed by some additional options that can further streamline your sign-in process.
         After that, I'll go into some more technical detail about how passkeys work and finally, discuss passkeys and multifactor authentication.
         First up, designing for passkeys.
         When it comes to talking about passkeys, first and foremost, passkeys are replacements for passwords.
         They're faster to sign in with, easier to use, and so much more secure.
         Here are some guidelines for how to refer to passkeys in your apps and websites.
         "Passkey" is a generic, user-visible term.
         This video focuses on Apple's implementation, but as I've just shown you, other major platforms have already started building their own support for passkeys.
         "Passkey" is also a common noun, like "password.
        " In English, this means it's lowercase and gets pluralized like "password" would.
         I have a passkey for my account, and I can go to Settings to view all of my accounts with passkeys.
         On Apple platforms, you can also use the SF Symbol person.key.
        badge and the .fill variant to provide iconography consistent with the system.
         When it comes to offering passkeys in your apps and websites, you don't need to design entire new interfaces.
         The user name field is the center point for most app and website sign-in today.
         Pretty much everyone knows how to use it, and many apps and websites already take advantage of it to tailor the sign-in experience per account.
         Now the user name field has another big feature.
         While passkeys bring new paradigms for how signing in works, the transition away from passwords needs to be smooth and easy too.
         You can now present passkeys using AutoFill as a first-class feature, letting you drop them right in to your existing sign-in flows, in an interface that's familiar and people know how to use.
         Presenting passkeys with AutoFill is the primary way you should use them.
         For more advanced uses though, Apple platforms also have a wide range of additional UI options for signing in with passkeys.
         Here's how to get started using passkeys and presenting them with AutoFill.
         Passkeys are built on the WebAuthentication -- or WebAuthn standard -- and use public-key cryptography.
         Rather than having a typable word or string, unique cryptographic key pairs are generated for every account.
         You'll need to adopt WebAuthn on your server back end in order to perform passkey sign-in.
         Any standard WebAuthn server implementation should work with passkeys.
         In apps on Apple platforms, passkeys are part of the ASAuthorization API family in the AuthenticationServices framework.
         This is our API for working with all kinds of different credentials, including passwords, security keys, and Sign in with Apple.
         We've also added a few new methods you can use, like AutoFill support, to make this API even more flexible and let you fit it in seamlessly in your existing sign-in flows.
         To get started using passkeys in your apps, first, you'll need to set up associated domains, using the webcredentials service.
         You can find more details about that in the "Introducing Password AutoFill for Apps" and "What's new in Universal Links" videos.
         In your app's interface, make sure your user name field is using the user name textContentTtype.
         This lets the system know where to offer passkey suggestions.
         Once that's configured, here's the code needed to start an AutoFill-assisted passkey request.
         It's just a few simple steps when you break it down.
         As with any WebAuthn request, you'll first need to fetch a challenge from your server.
         Then create the provider and the request.
         ASAuthorizationPlatformPublicKey CredentialProvider is the ASAuthorizationProvider for working with passkey requests.
         In WebAuthn terms, assertions are used when signing in, so here, I'm creating an assertion request to sign in with an existing passkey.
         ASAuthorizationController is what actually handles the request.
         Create an instance with the passkey request and configure its delegate and presentationContextProvider.
         And finally, call performAutoFillAssistedRequests to start the request.
         While this request is running in your app, whenever a user name field is focused, the system will offer available passkeys in the QuickType bar.
         Make sure to start this request early in your view lifetime before a user name field gets focused, so passkeys are ready when the keyboard appears.
         When an item from the QuickType bar is selected, Face ID gets invoked, then you'll receive an ASAuthorizationController Delegate callback to complete the sign-in.
         Nothing actually gets filled in your text field.
         When an authorization succeeds for any credential type, you'll get the didCompleteWithAuthorization callback.
         The first thing you should do is check the type of the credential that you got.
         In the case of passkey sign-in, it will be an ASAuthorizationPlatformPublicKey CredentialAssertion.
         The assertion object will contain the fields needed to verify the sign-in on your back end.
         You should read the values, verify them with your server, and complete the sign-in.
         AutoFill-assisted passkey requests are powerful.
         With that small code change, your app's sign-in flow now offers a lot of flexibility.
         The primary case, of course, is to select the passkey suggestion from the QuickType bar to sign in quickly with that passkey.
         This is what you should expect to happen most often.
         There are other options though.
         The code I just showed you also allows passkey sign-in from nearby devices with no additional changes.
         You can tap the key icon to bring up a view that lists all available passkeys and passwords and get to the option to sign in with a nearby device.
         Then you can perform a cross-device passkey sign-in.
         In both cases, if a passkey is used, you'll receive the same ASAuthorizationController Delegate callback.
         There's nothing special you need to do to support this.
         If a user doesn't have any passkeys yet, they can just use your login form like they're used to.
         They'll get password suggestions in the QuickType bar, or they can just type in the fields.
         If a password item is selected, the credential will still be filled in to your text fields, and you can cancel the running request.
         We designed this API to let you drop it right in to your existing sign-in flows and make it super easy for your users.
         If someone that has already upgraded to using a passkey decides to enter their user name anyway instead of using the AutoFill suggestion, you should cancel the AutoFill request and use ASAuthorizationController to present a modal passkey sign-in sheet.
         From here, it's still a single tap, and you'll receive the same ASAuthorizationController Delegate callback.
         Here's the code from before.
         To switch this from an AutoFill request to a modal request, just swap this performAutoFillAssistedRequests method call with a performRequests() call.
         This will present a modal sheet with all available passkeys as well as the option to use a passkey from a nearby device.
         Those are the only code changes you need in your app to support passkeys.
         The web platform also supports both AutoFill-assisted and modal passkey requests.
         On the web, passkeys are used via standard WebAuthn API, which is also used for security keys.
         Just like in apps, adopting AutoFill-assisted requests allows signing in quickly with just a Touch ID, getting to all of your available passkeys and passwords or using a passkey from a nearby device, all with very little code.
         First off, make sure to annotate your user name field on your webpage with both the username and webauthn autocomplete detail tokens, so that both password and passkey suggestions are shown in the right place.
         Once that's done, here's a typical WebAuthn sign-in, in JavaScript.
         In WebAuthn, AutoFill-style requests are invoked using conditional mediation.
         You should start by using standard JavaScript feature detection to check if it is available.
         If it is, you can proceed making your request.
         Just like with a native API, you'll start by making a request using a challenge fetched from your server.
         To make it an AutoFill-assisted request, add the mediation: "conditional" parameter to your options.
         Then, use navigator.credentials .get to start the request.
         The .get call returns a promise.
         If it resolves, you'll receive an assertion object, which you can send back to your server to verify, then complete the sign-in.
         Like in apps, if someone manually enters a user name for an account with a passkey, you should use the API to present a modal sign-in sheet.
         To switch to a modal request, all you need to do is remove the mediation: "conditional" parameter.
         One thing to note when using WebAuthn is how Apple platforms handle user verification -- or UV.
         UV is a Boolean field in a WebAuthn response that indicates whether the authenticator attempted to verify that the current user is the owner of the device.
         On Apple devices, a value of one indicates that biometrics, or a password or passcode were used.
         Apple platforms will always require UV for passkeys when biometrics are available, so you don't have to worry about that.
         When making WebAuthn requests, there's an option to specify a user-verification requirement.
         The default value is userVerification: "preferred".
         Always use the default value to avoid creating a bad experience on devices without biometrics.
         Here are some additional notes for using passkeys on the web.
         When you make AutoFill-assisted requests, you should make them early in the page lifetime, just like in apps.
         For modal WebAuthn requests, you should trigger them from a user gesture event, such as a button click.
         A modal request can be triggered once per page load outside of a user gesture event, but WebKit may limit subsequent calls on that page if you do so.
         AutoFill requests are not modal, so they don't require a user gesture and have a much longer timeout.
         Finally, passkeys are replacing Safari's legacy platform authenticator.
         Existing credentials will still work and still be bound to the device they were created on, but new platform credentials will be created as passkeys.
         They can be differentiated from legacy credentials during registration, as passkeys will not provide an attestation statement.
         That's passkeys and AutoFill.
         Next up, I'll go over some additional platform features that can further streamline your sign-in experience.
         In addition to the AutoFill-assisted sign-in, the ASAuthorization API provides many more useful features.
         I'm going to cover three additional features of the API and when you might want to use them.
         Starting with passkey allow lists.
         When presenting a modal passkey sheet after a user name is entered, it's possible that there are passkeys for multiple accounts saved on the device.
         All available passkeys will be shown in the sheet by default.
         You can use a passkey allow list to restrict which passkeys are shown in the sheet, so that only the matching account is offered.
         To add an allow list to a modal request, you'll first need the user name.
         You can use that user name to fetch a list of matching credential IDs and turn it into an allow list.
         A credential ID is a unique identifier for a passkey.
         A Webauthn server should have a way to look up credential IDs for a given user name.
         From here, just proceed with your request like before.
         Now, on my device which has three Shiny accounts using passkeys, the sheet only offers the single account I'm trying to use.
         When making modal requests, you should use an allow list when you have additional context about which account the user is trying to sign in with, such as if they've already typed in their user name.
         Next up, I'll cover what happens you make a modal passkey request if there are no passkeys saved on the current device.
         This also applies if you use an allow list and none of the saved passkeys match that list.
         By default, when you make a modal passkey request, if there are no matching passkeys available, the modal sheet will be displayed and will immediately show the QR code for signing in with a passkey from a nearby device.
         This provides most flexibility when signing in and is the best option when you know a passkey is being used.
         But there's a new option in the API to prefer credentials that are immediately available and fall back silently with a delegate callback if there aren't any.
         This can be used to quickly offer up existing credentials when possible, before even showing a traditional sign-in form.
         This modal request using the default options will fall back to showing a QR code if there are no matching passkeys on the current device.
         If you use the preferImmediately AvailableCredentials option, instead of getting a QR code, you'll receive a delegate callback with an error.
         If you receive an ASAuthorizationError with a code of canceled, that means either the user saw the sheet and manually dismissed it, or you passed preferImmediately AvailableCredentials and no credentials were immediately available.
         What you do from here depends on the context where you were calling this from.
         For example, if you were using this option as a way to test for local credentials before showing your normal sign-in form, this is where would trigger showing your form.
         If there's at least one matching credential on the device, the full modal sheet will be displayed regardless of the options used.
         Make sure you're also using either AutoFill-assisted requests or modal requests with the default fallback somewhere in your app, so that the option to sign in with a nearby device is still reachable if there are no passkeys on the current device.
         The last feature of the ASAuthorization API that I'll cover is making combined credential requests.
         In this example, the app made a request for passkeys, passwords, and Sign in with Apple.
         My device happens to have three different credentials for three different accounts saved, so they're all presented here.
         But a more likely scenario is that someone would only have a single account.
         In that case, this same combined credential request will only offer one account in the sheet.
         Adding additional credential types to an existing ASAuthorization request is really easy.
         You just need to create providers and requests for the additional request types, then pass those new requests to your controller.
         Now, the modal sheet will offer whatever credentials are available from any of these credential types.
         You'll get the same delegate callback regardless of which credential type is used.
         You should check the type of the credential you received and finish the sign-in as appropriate for that credential type.
         So that covers a few of the more advanced features of the ASAuthorization API family.
         Now, I'm going to dig in to some more technical details about how passkeys actually work and what makes them so secure.
         When you sign in with a password today, generally what's actually happening is after you enter that password, it gets hashed and salted, and the resulting obfuscated value is sent to the server, which stores it.
         Later, if you can produce the same hashed salted value, you're allowed into the account.
         This means the server is responsible for storing this derivation of your password, which is highly valuable to attackers.
         If they can get it, it's possible to figure out what your password is and gain access to your account.
         Passkeys, however, work very differently.
         Rather than having a single, typeable string, a passkey is actually a pair of related keys.
         These keys are generated by your devices, securely and uniquely, for every account.
         One is public and is stored on the server.
         The other is private and stays on your devices even when signing in.
         The public key is not a secret.
         It's just as public as your user name.
         The private key is what is needed to actually sign in.
         The server never learns what your private key is, and your devices keep it safe.
         When you go to sign in, the server sends your device a single-use challenge.
         WebAuthn allows many different challenge-response algorithms, but passkeys on Apple platforms use standard ES256.
         Only your private key is capable of producing a valid solution to the challenge for your account.
         Your device produces this solution -- called a signature -- locally, and only sends the solution back to the server.
         Your private key stays secret and only on your devices.
         The server then validates the solution using your public key.
         If the solution your device provided is valid, you're signed in! A public key can be used to check if a solution is valid but is not able to produce a solution itself.
         This means the server can be sure that you have the right private key, without knowing what the private key actually is.
         And since the server doesn't know any private keys, it's a less valuable target for attackers, because there are no user credentials to leak.
         All of this cryptography and key protection is totally transparent and performed by the devices.
         Your customers never have to know or think about it.
         From their perspective, passkeys are super simple and just work, everywhere.
         Passkeys can also be used to sign in across devices in a secure, phishing-resistant manner.
         Here's how that works.
         There are two devices here.
         The client, which is the device or web browser where I'm signing in, and the authenticator, which is the device which has my passkey.
         First, the client shows a QR code, which the authenticator scans.
         This QR code contains a URL that encodes a pair of single-use encryption keys.
         Then, the authenticator produces a Bluetooth advertisement containing routing information for a network relay server.
         This local exchange allows selecting a server and sharing routing information, but also serves two additional functions.
         It performs an out-of-band key agreement that the server can't see, so everything going over the network is end-to-end encrypted and the server can't read anything.
         It also provides a strong claim that these two devices are in physical proximity.
         That means a QR code sent in an email or generated on a fake website won't work, because a remote attacker won't be able receive the Bluetooth advertisement and complete the local exchange.
         So that's the local part.
         Once the local exchange and key agreement have happened, the two devices connect to a relay server picked by the phone.
         From there, they perform a standard FIDO CTAP operation, which is encrypted using the keys from earlier, so the relay server can't see anything that's going on.
        This whole process is performed by the device and the web browser.
         The website is not involved at any point in the cross-device communication.
         Cross-device cross-platform sign-in is a system feature that just works anywhere passkeys can be used.
         So that's a more technical look into how passkeys work and how they can make such strong security guarantees, even across devices.
         Next up, multifactor authentication.
         A common way to think about authentication today is in terms of factors.
         Different factors are strong or weak against different kinds of attacks, and combining factors can provide better collective coverage.
         But with passkeys, you don't need to think like that anymore.
         Here are some of the most common methods used to sign in today.
         Passwords in your head are vulnerable to pretty much everything.
         Password managers are good at generating unique, high-entropy strings, may have local protections against device theft, and offer some hints about phishing.
         Adding an SMS or time-based code can help with theft or phishing in some circumstances but doesn't really solve either.
         With passkeys though, every passkey is a unique, device-generated key pair.
         On Apple devices, they're built on a strong foundation of local device protections.
         Passkeys also completely eliminate the human factor from phishing.
         And they can't be leaked by an app or website server, because the servers don't have the private keys.
         Adding factors to a password-based sign-in flow makes sense, as together they can protect against more types of attacks than passwords alone.
         But a passkey alone protects against so much more that it doesn't need additional factors.
         I'm looking forward to a future without passwords.
         Here's how you can get started making that happen.
         First off, you'll need to adopt WebAuthn on your server, if you haven't already done so.
         Passkeys should work with any standard WebAuthn server implementation.
         Once your server is ready to go, adopt our new API in your apps and websites.
         AutoFill-assisted passkey requests can be dropped right in to your existing sign-in flows, plus we have a range of more advanced UI options as well, if you need them.
         And finally, transition your users away from passwords.
         Passkeys are an industry-standard solution to the convenience and security problem of securely signing in to apps and websites.
         By guiding your customers to passkeys and away from passwords, you can give them an incredibly quick and convenient sign-in experience while raising the security bar for everyone.
         Thank you.

        """
    }

    var japanese: String {
        """
        こんにちは、私はAuthentication Experienceチームのエンジニア、ギャレットです。
         そしてこのビデオでは、次世代認証技術であるパスキーについてお話したいと思います。
         でもその前に、今日の認証技術であるパスワードについてお話しする必要があります。
         皆さんは、ほぼすべてのアプリやウェブサイトにパスワードでサインインすることに慣れていることでしょう。
         パスワードは、安全に使うのが本当に難しいものです。
         すべてのアカウントに強力でユニークなパスワードを作成する必要があることは誰もが知っていますが、実際にそうしている人はあまりいません。
         アプリやウェブサイトを設計する際、アカウントの安全性を確保することと、優れたエクスペリエンスを設計することは、常にトレードオフの関係にあります。
         また、アプリやウェブサイトがすべて正しく動作していても、フィッシングやパスワードの再利用などの問題がアカウントの侵害につながる可能性があります。
         macOS MontereyとiOS 15では、その解決策となるpasskeysのデベロッパープレビューを発表し、多くの素晴らしいフィードバックをいただきました。
         macOS VenturaとiOS 16では、すべての人にpasskeysを提供できることをうれしく思います。
         今こそ、このソリューションを採用するときです。
         パスキーを使えば、パスワードよりも優れたユーザー体験を実現できるだけでなく、脆弱な認証情報や再利用される認証情報、認証情報の漏洩、フィッシングなど、セキュリティ問題の全カテゴリーを解決することが可能になるのです。
         しかも、使い方はとても簡単です。
         では、お見せしましょう。
         まず、私たちのお気に入りのデモ・アプリケーションである「Shiny」から始めましょう。
         このアプリでは、1日に1枚、かわいい写真を見ることができ、典型的なパスワードベースのサインインフローを備えています。
         ユーザー名フィールドをタップすると、私のアカウントに対する自動入力の候補が表示されます。
         それを選択して、サインインします。
         そして、パスワードを入力します。
        そして、SMSメッセージでワンタイムコードが送られてくるまで、少し待ちます。
        ほら、これだ。
         そして、最終的にサインインが完了しました。
         少し手間取りましたが、AutoFillとパスワードマネージャの助けを借りて、ここまでたどり着くことができました。
        さて、サインインできたので、このアカウントにパスキーを追加してみます。
         アカウント管理」→「パスキーの追加」。
         ここで、パスキーを作成するためのシステムシートが表示されました。
         続けて
         完了です。数回タップするだけで、私のデバイスは私のアカウント用にユニークで暗号的に強力なキーペアを生成し、それを私のiCloudキーチェーンに保存します。
        パスキーができたので、使い勝手を紹介しましょう。
         サインアウトして、先ほどと同じサインインフォームに戻ります。
         先ほどと同じようにユーザー名フィールドにフォーカスしてみます。
         アカウント用のパスキーが保存されているので、それがQuickTypeバーに表示されます。
         あとはこれをタップすれば、サインイン完了です。
         一手間。
         パスキーを保存する際に、新しいパスワードを考えたり、複雑な条件を満たそうとしたりする必要はありませんでした。
         それぞれのパスキーはシステムによって生成され、強度が保証されており、1つのアカウントにのみ使用されます。
         そして、それを使ってサインインするときは、使い慣れた既存のサインインフローで表示でき、ワンタップで使えるんです。
         しかも、正しいアプリやウェブサイトでだけ使わせるように配慮され、強力なフィッシング耐性が内蔵されています。
         もちろん、パスキーはウェブ上でも使えます。
         ここでは、Safariでシャイニーのウェブサイトを見ています。
         携帯電話と同じように、ユーザー名フィールドにフォーカスすると、iCloud Keychainのおかげで私のパスキーがすでにそこにあり、すぐに使える状態になっています。
         あとはTouch IDでサインインするだけです。
         これだけです。
         Appleのパスキーの実装は、オープンな標準に基づいて構築されています。
         私たちは、FIDOアライアンス内の他のプラットフォームベンダーと協力して、パスキーの実装がクロスプラットフォームで互換性を持ち、できるだけ多くのデバイスで動作するようにしました。
         私のアカウントをパスキーを使うようにアップグレードした後も、友人のPCからサインインすることができます。
         もちろん、友人のPCにはローカルにパスキーは保存されていないが、ここでユーザー名を入力することはできる。
         サインインを押すと、携帯電話を使わせてくれるというシートが表示されます。
         すると、QRコードが表示されます。
         これをスキャンします。
        このQRコードはパスキーを使ってサインインするためのものだと認識されます。
         このオプションを選択すると、私の携帯電話とブラウザが安全に接続されます。
         あとは「続ける」だけで、サインインが完了します。
         このクロスプラットフォームでのサインイン体験は、パスキーの背後にある標準の一部であり、第一級のシステム機能です。
         一見、とてもシンプルに見えますが、これは単なるQRコードではありません。
         裏側では、デバイスがローカルな鍵の合意を行い、近接性を証明し、エンドツーエンドの暗号化通信路を確立しています。すべては、簡単な方法でサインインできるようにするためですが、passkeysの強力なフィッシング耐性を維持するためです。
         どのようなデバイスからでも自分のアカウントに安全にサインインできるようにするために、とても役立っています。
         また、パスワードの代わりとして重要なのが、2人以上でアカウントを共有できる機能です。
         パスキーを誰かと共有するには、AirDropを使えばいいんです。
        私とパートナーはShinyのアカウントも共有しており、こちらはすでにパスキーを使うようにアップグレードしています。
         パスキーの場合、クレデンシャルを入力することはできませんが、信頼できる人たちと共有することはできます。
         携帯電話で、アカウントの詳細を開いてみます。
        ここに私のすべてのアカウントがあり、パスワードとパスキーの両方が使用されています。
         私はより多くの詳細をプルアップするために私たちの共有アカウントをタップすることができます.
         ここでは、保存したパスキーの情報を取得したり、このアカウントにメモを追加したりすることができます。
         パスキーを共有することもできます。
         パートナーの携帯電話があります。
         それを選択します。
        これで私のパートナーもパスキーを持つことができます。
        このように、どこでも簡単にパスキーを使うことができるのです。
         ここまでで、パスキーの使い方を説明しました。
         次に、パスキーとは何か、パスキーを使用する際のインターフェースのガイドラインについて説明します。
         次に、AutoFillを活用して、アプリやWebサイトの既存のサインインフローにパスキーを統合する方法を紹介し、続いて、サインインプロセスをさらに効率化できる追加オプションをいくつか紹介したいと思います。
         その後、パスキーの仕組みについてもう少し技術的に詳しく説明し、最後にパスキーと多要素認証について説明します。
         まず最初に、パスキーのデザインについてです。
         パスキーについて語るとき、何よりもまず、パスキーはパスワードの代用品です。
         パスキーはより速くサインインでき、より簡単に使用でき、より安全です。
         以下は、アプリやウェブサイトでパスキーをどのように呼ぶかのガイドラインです。
         「Passkey "は、一般的な、ユーザが目にすることのできる用語です。
         このビデオはAppleの実装に焦点を当てていますが、先ほど紹介したように、他の主要なプラットフォームもすでにパスキーの独自のサポートを構築し始めています。
         "Passkey "はまた、"password "のような一般名詞でもあります。
        " 英語では小文字で、"password" のように複数形になることを意味します。
         私は自分のアカウントにパスキーを持っていて、「設定」でパスキー付きのアカウントをすべて見ることができます。
         Appleのプラットフォームでは、SFシンボルのperson.key.badgeと.fillのバリエーションも使用できます。
        badgeと.fillのバリアントで、システムと一貫性のあるアイコンを提供できます。
         アプリやウェブサイトでパスキーを提供する場合、まったく新しいインターフェースをデザインする必要はありません。
         ユーザー名フィールドは、今日、ほとんどのアプリやWebサイトのサインインの中心的なポイントです。
         多くの人がその使い方を知っており、すでに多くのアプリやWebサイトが、アカウントごとにサインイン体験をカスタマイズするために、このフィールドを活用しています。
         そして今、ユーザー名フィールドに、もうひとつの大きな特徴が加わりました。
         パスキーはサインインの仕組みに新しいパラダイムをもたらしますが、パスワードからの移行もスムーズで簡単である必要があります。
         AutoFillを使用したパスキーは、ファーストクラスの機能として、既存のサインインフローにそのまま組み込むことができます。
         AutoFillを使用したパスキーの提示は、パスキーの主要な使用方法です。
         しかし、より高度な使い方として、Appleのプラットフォームには、パスキーを使ったサインイン用の幅広い追加UIオプションがあります。
         ここでは、パスキーの使用方法とAutoFillを使用したパスキーの表示方法について説明します。
         Passkeys は WebAuthentication または WebAuthn 標準をベースに構築されており、公開鍵暗号方式を使用します。
         入力可能な単語や文字列ではなく、一意の暗号キー ペアがアカウントごとに生成されます。
         パスキーによるサインインを行うには、サーバーのバックエンドに WebAuthn を採用する必要があります。
         標準的な WebAuthn サーバーの実装であれば、パスキーに対応することができます。
         Apple プラットフォームのアプリでは、パスキーは AuthenticationServices フレームワークの ASAuthorization API ファミリーに含まれます。
         これは、パスワード、セキュリティ キー、Sign in with Apple など、あらゆる種類の認証情報を扱うための API です。
         また、AutoFillのサポートなど、使用できる新しいメソッドもいくつか追加され、このAPIをさらに柔軟にして、既存のサインインフローにシームレスに適合させることができるようになりました。
         アプリでパスキーを使い始めるには、まず、webcredentials サービスを使用して、関連するドメインを設定する必要があります。
         詳細は、ビデオ「Introducing Password AutoFill for Apps」と「What's new in Universal Links」でご覧いただけます。
         アプリのインターフェイスで、ユーザー名フィールドがユーザー名textContentTypeを使用していることを確認します。
         これにより、パスキーの候補を提供する場所がシステムに通知されます。
         この設定が完了したら、AutoFillによるパスキーリクエストを開始するために必要なコードを以下に示します。
         分解してみると、いくつかの簡単なステップに過ぎません。
         他の WebAuthn リクエストと同様に、まずサーバーからチャレンジを取得する必要があります。
         次に、プロバイダとリクエストを作成します。
         ASAuthorizationPlatformPublicKey CredentialProvider は、パスキー リクエストを扱うための ASAuthorizationProvider です。
         WebAuthn の用語では、サインイン時にアサーションを使用するため、ここでは既存のパスキーでサインインするためのアサーションリクエストを作成しています。
         実際にリクエストを処理するのは ASAuthorizationController です。
         パスキーリクエストでインスタンスを作成し、そのデリゲートとpresentationContextProviderを設定します。
         そして最後に、performAutoFillAssistedRequests を呼び出して、リクエストを開始します。
         このリクエストがアプリで実行されている間は、ユーザー名フィールドがフォーカスされるたびに、システムが QuickType バーに利用可能なパスキーを提供します。
         キーボードが表示されたときにパスキーの準備ができるように、ユーザー名フィールドがフォーカスされる前に、ビューライフタイム内の早い段階でこのリクエストを開始するようにしてください。
         QuickType バーの項目が選択されると Face ID が呼び出され、ASAuthorizationController Delegate コールバックを受け取ってサインインを完了します。
         テキストフィールドには、実際には何も入力されません。
         どの種類のクレデンシャルでも認証に成功すると、didCompleteWithAuthorizationコールバックを受け取ります。
         最初にすべきことは、取得したクレデンシャルの種類を確認することです。
         パスキーによるサインインの場合、それは ASAuthorizationPlatformPublicKey CredentialAssertion となる。
         アサーション・オブジェクトには、バックエンドでサインインを検証するために必要なフィールドが含まれる。
         値を読み込んでサーバで検証し、サインインを完了させる必要がある。
         AutoFill によるパスキーリクエストは強力です。
         この小さなコード変更により、アプリのサインインフローは多くの柔軟性を持つようになりました。
         もちろん、主なケースは、QuickTypeバーからパスキーの候補を選択して、そのパスキーですばやくサインインすることです。
         これは、最も頻繁に発生すると予想されることです。
         しかし、他の選択肢もあります。
         先ほど紹介したコードでは、追加の変更なしに近くのデバイスからパスキーサインインすることも可能です。
         鍵のアイコンをタップして、利用可能なすべてのパスキーとパスワードを一覧表示するビューを表示し、近くのデバイスでサインインするオプションにたどり着くことができます。
         その後、クロスデバイスのパスキーサインインを実行できます。
         どちらの場合も、パスキーが使われると、同じASAuthorizationController Delegateコールバックを受け取ります。
         これをサポートするために必要な特別なことは何もありません。
         もしユーザーがまだパスキーを持っていない場合は、ログインフォームをそのまま使用することができます。
         QuickTypeバーにパスワードの候補が表示されますし、フィールドに入力することもできます。
         パスワードの項目が選択された場合でも、クレデンシャルはテキストフィールドに入力され、実行中のリクエストをキャンセルすることができます。
         このAPIは、既存のサインインフローにそのまま追加できるように設計されており、ユーザーにとって非常に使いやすいものとなっています。
         既にパスキーの使用にアップグレードした人が、AutoFill の提案を使う代わりに、とにかくユーザ名を入力しようと決めた場合、AutoFill のリクエストをキャンセルして、ASAuthorizationController を使ってモーダルパスキーサインインシートを表示させる必要があります。
         ここからはシングルタップで、同じ ASAuthorizationController Delegate のコールバックを受け取ることができます。
         以下は、以前のコードです。
         AutoFill リクエストからモーダルリクエストに切り替えるには、この performAutoFillAssistedRequests メソッドの呼び出しを performRequests() の呼び出しに置き換えるだけです。
         これにより、利用可能なすべてのパスキーと、近くのデバイスからのパスキーを使用するオプションが表示されたモーダル シートが表示されます。
         アプリでパスキーをサポートするために必要なコードの変更は、これだけです。
         Web プラットフォームも、AutoFill アシストとモーダルパスキーの両方のリクエストをサポートしています。
         Web では、セキュリティ キーにも使用される標準の WebAuthn API を介してパスキーが使用されます。
         アプリと同様に、AutoFill アシスト リクエストを採用すると、Touch ID だけですばやくサインインしたり、利用可能なすべてのパスキーとパスワードを取得したり、近くのデバイスからパスキーを使用したりすることができ、これらはすべて非常に少ないコードで実現できます。
         まず最初に、ウェブページのユーザー名フィールドにユーザー名と webauthn オートコンプリートの詳細トークンの両方を注釈して、パスワードとパスキーの両方の候補が正しい場所に表示されるようにしてください。
         これが完了したら、JavaScript による典型的な WebAuthn サインインをご覧ください。
         WebAuthn では、AutoFill スタイルのリクエストは条件付き調停を使用して呼び出されます。
         まず、標準的な JavaScript の機能検出を使用して、それが利用可能かどうかを確認することから始める必要があります。
         利用可能であれば、リクエストの作成を進めることができます。
         ネイティブ API と同様に、サーバーから取得したチャレンジを使用してリクエストを作成することから始めます。
         オートフィルアシストリクエストにするには、オプションにmediation.Conditionalを追加します。「conditional "パラメータをオプションに追加します。
         それから、navigator.credentials .getを使用してリクエストを開始します。
         .getの呼び出しは、プロミスを返します。
         解決されると、アサーションオブジェクトを受け取り、それをサーバーに送り返して検証し、サインインを完了させることができます。
         アプリと同様に、誰かが手動でパスキー付きのアカウントのユーザー名を入力した場合、API を使用してモーダルサインインシートを表示する必要があります。
         モーダルリクエストに切り替えるために必要なのは、mediationを削除することです。"conditional "パラメータを削除するだけです。
         WebAuthn を使用する際に注意すべき点は、Apple プラットフォームがユーザー認証、つまり UV をどのように扱うかということです。
         UV は WebAuthn レスポンスのブール値フィールドで、認証者が現在のユーザがデバイスの所有者であることを確認しようとしたかどうかを示します。
        Appleデバイスでは、値が1の場合、バイオメトリクス、またはパスワードやパスコードが使用されたことを示します。
        Apple のプラットフォームでは、生体認証が利用可能な場合は常にパスキーの UV が要求されるので、その心配はありません。
        WebAuthn のリクエストを行う際に、ユーザー認証の要件を指定するオプションがあります。
        デフォルトは userVerification です。「preferred」です。
        生体認証のないデバイスで悪い経験をしないように、常にデフォルト値を使用してください。
        以下は、ウェブ上でパスキーを使用する際の追加注意事項です。
        AutoFill アシストリクエストを行うときは、アプリと同じように、ページのライフタイムの早い段階で行う必要があります。
        モーダルな WebAuthn リクエストの場合、ボタンのクリックなど、ユーザーのジェスチャー イベントをトリガーとしてリクエストする必要があります。
        モーダル リクエストは、ユーザーのジェスチャー イベント以外でも、ページの読み込みごとに 1 回だけ起動できますが、起動すると WebKit によってそのページでの後続の呼び出しが制限される場合があります。
        AutoFill リクエストはモーダルではないので、ユーザー ジェスチャを必要とせず、タイムアウトも長くなっています。
        最後に、Safari のレガシーなプラットフォーム認証機能をパスキーが置き換えます。
        既存の認証情報は引き続き使用でき、作成されたデバイスにバインドされますが、新しいプラットフォームの認証情報はパスキーとして作成されます。
        パスキーは認証文を提供しないので、登録時に従来のクレデンシャルと区別することができます。
        以上がパスキーとAutoFillでした。
        次に、サインイン体験をさらに効率化できるプラットフォームの追加機能について説明します。
        AutoFillによるサインインに加え、ASAuthorization APIはさらに多くの便利な機能を提供しています。
        ここでは、APIの3つの追加機能と、それらをどのような場合に使用したいかを説明します。
        パスキー許可リストで始める
        ユーザー名入力後にモーダルパスキー・シートを提示する場合、端末に複数のアカウントのパスキーが保存されている可能性があります。
        デフォルトでは、利用可能なすべてのパスキーがシートに表示されます。
        パスキーの許可リストを使用して、シートに表示されるパスキーを制限し、一致するアカウントのみが提供されるようにすることができます。
        モーダルリクエストに許可リストを追加するには、まず、ユーザー名が必要です。
        そのユーザー名を使って、一致するクレデンシャル ID のリストを取得し、それを許可リストにすることができます。
        クレデンシャル ID とは、パスキーの一意な識別子です。
        Webauthn サーバーは、与えられたユーザー名のクレデンシャル ID を調べる方法を備えているはずです。
        ここからは、先ほどと同じようにリクエストを進めるだけです。
        さて、パスキーを使用して3つのShinyアカウントを持つ私のデバイスでは、シートは私が使用しようとしている1つのアカウントのみを提供します。
        モーダル リクエストを作成する場合、ユーザーがどのアカウントでサインインしようとしているか、例えばユーザー名をすでに入力しているかなどの追加情報があるときは、許可リストを使用する必要があります。
        次は、現在のデバイスにパスキーが保存されていない場合に、モーダルパスキーのリクエストを行うとどうなるかを説明します。
        これは、許可リストを使用していて、保存されているパスキーのどれもがそのリストに一致しない場合にも当てはまります。
        デフォルトでは、モーダルパスキーリクエストを行う際、一致するパスキーがない場合は、モーダルシートが表示され、近くのデバイスからパスキーでサインインするための QR コードがすぐに表示されます。
        これはサインイン時に最も柔軟性があり、パスキーが使用されていることが分かっている場合には最適なオプションです。
        しかし、APIには新しいオプションがあり、すぐに利用できるクレデンシャルを優先し、ない場合はデリゲートコールバックで静かにフォールバックするようになっています。
        これは、従来のサインインフォームを表示する前に、可能であれば既存のクレデンシャルを迅速に提供するために使用できます。
        デフォルトのオプションを使用したこのモーダルリクエストは、現在のデバイスに一致するパスキーがない場合、QR コードを表示するようにフォールバックされます。
        preferImmediately AvailableCredentials オプションを使用すると、QR コードを取得する代わりに、エラー付きのデリゲートコールバックを受け取ります。
        ASAuthorizationError を canceled というコードで受け取った場合、ユーザがシートを見て手動で解除したか、preferImmediately AvailableCredentials を渡してすぐに利用できる認証情報がなかったかのどちらかを意味します。
        ここからどうするかは、これを呼び出したときのコンテキストに依存します。
        たとえば、通常のサインインフォームを表示する前にローカルのクレデンシャルをテストするためにこのオプションを使っていた場合、ここでフォームを表示することになります。
        デバイス上に少なくとも 1 つの一致するクレデンシャルがある場合、使用するオプションに関係なく、フル モーダル シートが表示されます。
        現在のデバイスにパスキーがない場合でも、近くのデバイスでサインインするオプションに到達できるように、アプリ内のどこかで AutoFill アシスト リクエストまたはデフォルト フォールバックでのモーダルリクエストを使用していることも確認してください。
        ASAuthorization API の最後の機能として、複合クレデンシャルリクエストを作成することを説明します。
         この例では、アプリがパスキー、パスワード、Sign in with Appleを要求しています。
         私のデバイスにはたまたま3つの異なるアカウントの認証情報が保存されていたので、ここにすべて表示されています。
         しかし、より可能性の高いシナリオは、誰かが1つのアカウントしか持っていない場合です。
         その場合、この同じ複合クレデンシャルリクエストは、シートで1つのアカウントのみを提供します。
         既存のASAuthorizationリクエストに追加のクレデンシャルタイプを追加するのは、本当に簡単です。
         追加のリクエストタイプのためのプロバイダとリクエストを作成し、それらの新しいリクエストをコントローラに渡すだけです。
         これで、モーダルシートは、これらのクレデンシャルタイプのいずれかから利用可能なクレデンシャルを提供することになります。
         どのクレデンシャルタイプが使用されても、同じデリゲートコールバックが得られます。
         受け取ったクレデンシャルのタイプを確認し、そのクレデンシャルタイプに適した方法でサインインを完了させる必要があります。
         以上で、ASAuthorization API ファミリーの高度な機能のいくつかをカバーしました。
         さて、ここからはパスキーが実際にどのように機能し、何がそれを安全にしているのか、より技術的な詳細を掘り下げていきたいと思います。
         今日、あなたがパスワードでサインインするとき、一般的に実際に起こっていることは、あなたがパスワードを入力した後、パスワードはハッシュ化され塩漬けされ、結果として難読化された値がサーバーに送られ、サーバーはそれを保存します。
         その後、同じハッシュ化されたソルト値を生成できれば、そのアカウントへのアクセスが許可されます。
         つまり、サーバーは、攻撃者にとって非常に価値のあるパスワードの導出を保存する責任があるのです。
         もし、これを入手できれば、あなたのパスワードが何であるかを突き止め、アカウントにアクセスすることが可能になるのです。
         しかし、パスキーの仕組みはまったく異なります。
         パスキーは、入力可能な単一の文字列ではなく、実際には関連する2つのキーの組で構成されています。
         これらのキーは、アカウントごとに、安全かつ一意にデバイスで生成されます。
         1つは公開鍵で、サーバーに保存されます。
         もう一方は秘密鍵で、サインインしている間もあなたのデバイスに残ります。
         公開鍵は秘密ではありません。
         あなたのユーザー名と同じように公開されています。
         秘密鍵は、実際にサインインするために必要なものです。
         秘密鍵はサーバーに知られることはなく、あなたのデバイスで安全に管理されます。
         サインインしようとすると、サーバーはあなたのデバイスに一回限りのチャレンジを送ります。
         WebAuthn ではさまざまなチャレンジ・レスポンス・アルゴリズムが使用できますが、Apple プラットフォームのパスキーは標準の ES256 を使用しています。
         あなたの秘密鍵だけが、あなたのアカウントに対するチャレンジの有効な解を生成することができます。
         あなたのデバイスは、署名と呼ばれるこの解をローカルに生成し、その解をサーバに送り返すだけです。
         あなたの秘密鍵は、あなたのデバイスにのみ保存され、秘密にされます。
         サーバーは、あなたの公開鍵を使って解決策を検証します。
         あなたのデバイスが提供したソリューションが有効であれば、あなたはサインインしたことになります。公開鍵は、ソリューションが有効かどうかを確認するために使用できますが、ソリューションそのものを生成することはできません。
         つまり、秘密鍵が実際に何であるかを知らなくても、サーバーはあなたが正しい秘密鍵を持っていることを確認することができるのです。
         また、サーバーは秘密鍵を知らないので、漏えいするユーザー認証情報がなく、攻撃者のターゲットとしては価値が低いのです。
         この暗号と鍵の保護はすべて、完全に透過的であり、デバイスによって実行されます。
         顧客はそれを知ることも考えることもありません。
         顧客から見れば、パスキーは非常にシンプルで、どこでも使えるということです。
         また、パスキーはフィッシングに強い安全な方法で、デバイス間のサインインに使用することができます。
         その仕組みはこうです。
         ここには2つのデバイスがあります。
         クライアント（サインインするデバイスまたはウェブブラウザ）と、オーセンティケータ（私のパスキーを持つデバイス）です。
         まず、クライアントがQRコードを表示し、それを認証側が読み取ります。
         このQRコードには、1回しか使えない暗号鍵のペアをコード化したURLが含まれています。
         次に、ネットワーク中継サーバーのルーティング情報を含むBluetoothアドバタイズを生成します。
         このローカル交換により、サーバーの選択とルーティング情報の共有が可能になりますが、さらに2つの機能が追加されます。
         サーバには見えない帯域外の鍵合意を行うため、ネットワーク上を流れるものはすべてエンドツーエンドで暗号化され、サーバは何も読むことができない。
         また、2つのデバイスが物理的に近接していることを強く主張することができます。
         つまり、電子メールで送信されたQRコードや偽のウェブサイトで生成されたQRコードは機能しません。遠隔地の攻撃者はBluetoothアドバタイズを受信してローカル交換を完了することができないためです。
         つまり、これがローカルな部分です。
         ローカル交換と鍵の合意が行われると、2つのデバイスは電話機が選んだリレーサーバーに接続します。
         そこでは、標準的なFIDO CTAP操作が行われます。この操作は、先ほどの鍵を使って暗号化されているので、リレーサーバーには何が起こっているのかが見えません。
        このプロセス全体は、デバイスとウェブブラウザによって実行されます。
         ウェブサイトは、クロスデバイスの通信には一切関与しません。
         クロスデバイス、クロスプラットフォームでのサインインは、パスキーが使える場所であればどこでも機能するシステム機能なのです。
         以上、パスキーの仕組みと、デバイスをまたいでも強力なセキュリティ保証ができる理由について、より技術的に見てきました。
         次は、多要素認証です。
         現在、認証は「要素」で考えるのが一般的です。
         異なる種類の攻撃に対して、異なる因子が強かったり弱かったり、因子を組み合わせることで、より優れた集団的なカバーが可能になります。
         しかし、パスキーを使えば、もうそのような考え方は必要ありません。
         今日、サインインに最もよく使われる方法を紹介します。
         頭の中にあるパスワードは、かなり脆弱です。
         パスワード管理ソフトは、ユニークなハイエントロピーの文字列を生成するのに優れており、デバイスの盗難に対するローカルな保護機能を持ち、フィッシングに関するいくつかのヒントを提供しています。
         SMSやタイムベースのコードを追加することで、盗難やフィッシングに対処できる場合もありますが、本当の解決にはなりません。
         しかし、パスキーは、デバイスが生成するユニークなキーペアです。
         Appleのデバイスでは、パスキーはローカルデバイスの保護という強力な基盤の上に構築されています。
         また、パスキーはフィッシングの人的要因も完全に排除します。
         また、アプリやウェブサイトのサーバーは秘密鍵を持っていないため、漏洩することはありません。
         パスワードベースのサインインフローに要素を追加することは、パスワードだけよりも多くの種類の攻撃から保護することができるため、理にかなっています。
         しかし、パスキーだけでも多くの攻撃から守ることができるので、追加の要素は必要ないのです。
         パスワードのない未来が楽しみです。
         ここでは、それを実現するための方法を紹介します。
         まず最初に、WebAuthn をサーバに導入する必要があります（まだ導入していない場合）。
         Passkeys は、標準的な WebAuthn サーバの実装であれば動作するはずです。
         サーバーの準備ができたら、あなたのアプリケーションやウェブサイトで新しい API を採用してください。
         AutoFill によるパスキー リクエストは、既存のサインイン フローに組み込むことができます。また、必要に応じて、より高度な UI オプションも用意しています。
         そして最後に、ユーザーをパスワードから解放してください。
         パスキーは、アプリケーションやウェブサイトに安全にサインインするための、利便性とセキュリティの問題を解決する業界標準のソリューションです。
         顧客をパスワードからパスキーに誘導することで、信じられないほど迅速で便利なサインイン体験を提供しながら、すべての人のセキュリティレベルを引き上げることができます。
         ありがとうございました。

        """
    }
}

