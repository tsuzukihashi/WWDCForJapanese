import Foundation

struct ExploreMoreContentWithMusicKit: ArticleProtocol {
    var id: String {
        UUID().uuidString
    }

    var title: String {
        "Explore more content with MusicKit"
    }

    var imageUrl: URL {
        URL(string: "https://devimages-cdn.apple.com/wwdc-services/images/124/6700/6700_wide_250x141_2x.jpg")!
    }

    var link: URL {
        URL(string: "https://developer.apple.com/videos/play/wwdc2022/110347/")!
    }

    var english: String {
        """
        Hi, and welcome to WWDC.
         My name is David, and I'd like to tell you about how you can explore more content with MusicKit.
         The MusicKit framework was launched in 2021, providing a set of APIs to access and play music natively in Swift.
         This framework makes it easy for your app to integrate with Apple Music, providing access to the entire Apple Music catalog.
         Today, I'd like to talk about some of the major enhancements we've made to MusicKit.
         I'll start off with some additions to get even more out of the Apple Music catalog, with new music item types, new requests, and new metadata.
        After that, I'll discuss how you can fetch personalized content to provide a tailored experience for each of your users.
         Next up, I'll go beyond the Apple Music catalog.
         This year, you can take your app to a whole new level by including music from your user's library.
         Finally, I'll discuss how to actively interact with the library, such as adding items to the library or a playlist, as well as creating and editing playlists.
         Let's dive into the catalog content additions.
         The initial release of MusicKit introduced a new model layer for music, including core types like Songs, Albums, and Playlists.
         This year, we're making it easier to discover new music with MusicKit with the addition of two new types: Curator and Radio Show.
        Beyond that, MusicKit now also allows you to build great UI for searching through the catalog, access top charts to get the most popular songs, albums, and more, and fetch new attributes such as higher quality audio metadata like Spatial Audio with Dolby Atmos.
        Let's start with curators and radio shows, which are fantastic resources for music discovery.
         Here, we're taking a look at an example Curator, Nike.
         Other examples of curators are Shazam and Beats by Dr.
         Dre.
         Here, we can easily find all of the playlists generated by this curator.
         This functionality allows people to get quick access to playlists they may love, finding new songs or revisiting old favorites.
         Now let's dive into the more technical details.
        Curators host a variety of attributes.
         Some of the primary attributes of this new Curator type are name, url, artwork, and kind.
         The kind property is an enum that can either be "editorial" or "external" indicating whether a given curator is an Apple curator or a third party curator.
        Curators also have a playlists relationship showing playlists made by that curator, truly servicing the music discovery notion we just saw.
        Next, we have the Radio Show type.
         Radio Shows like "New Music Daily by Zane Lowe" and "Pop Hits Radio by Brooke Reese" are another way to discover new music through seasoned professionals.
         Much like the Curator type, radio shows also have a playlists relationship to find the music a radio show features.
         Just as these two new types hold relationships to playlists, we are also exposing two new relationships on the Playlist type, "Curator" and "RadioShow" for the reversed logic: that given a playlist, we can easily get the structure of which entity generated said playlist.
        MusicKit allows searching the catalog for content from a plethora of types, and now we're adding support for our new item types, like curators and radio shows.
         The list just continues to grow, and as a result, building good UI becomes more and more challenging.
         That's why this year, we're making it much easier for you through top results and suggestions.
         Let's take a look at the utility these enhancements bring to a UI.
         When typing to search for content, you may want to provide strong, music-related auto-complete support.
         That's where suggestions come into play, providing terms that people may be trying to reach.
         You can even take it a step further and display top results for quick access to what people may be searching for.
         For the best results, you may not care about the type of the item, but instead want to focus on relevancy.
         This is the power of top results.
         Now, let's take a look at what implementing this would look like, starting with Top Results.
         Here we have the existing way to create a catalog search request, requiring a search term and the types of items that you want represented.
         The response includes collections categorized by the requested types, meaning multiple lists of type specific results.
         Although this is great, we want to expose a single list of the most relevant results that is type agnostic.
         And requesting this information is as simple as adding one line.
         Here we're setting the includeTopResults property on the request to true, and a new property is filled in the response.
         This new property is named topResults which contains items of any of the requested types.
         Here's what the output of the print statement looks like.
         We can see that the top results returned are a mix of songs, artists, and albums in a single collection and is ordered by relevancy.
         Now I'll show you how to help people get to their search destination faster with Suggestions.
         Simply create a suggestions request with a string term.
         Upon calling response, you'll get back a suggestions response.
         The response contains an array of Suggestions.
         And each suggestion includes a display term which is suitable for your UI, as well as a search term.
         When people select a suggestion, you can fetch the corresponding results by performing a search request with the search term.
        Catalog charts are a great way to stay up-to-date with the most popular songs.
         MusicKit offers various types of charts to see what's trending.
         The types of charts being offered are top charts, such as Top Songs or Top Albums, which correspond to the most played music, city charts, and daily top 100.
         You may also specify the requested charts to be filtered by a specific genre.
         Retrieving these charts through code is extremely simple.
         The catalog charts request follows established patterns already used in the catalog search request.
         First, initialize a charts request.
         You can then specify the kinds of charts you'd like.
         By default, this will fetch the most played content, but you can also include daily global top charts and city top charts.
         Lastly, just specify the types you want your charts to contain.
         And that's it.
         When we access the first playlist chart in the response, we get a MusicCatalogChart representing the daily global top charts.
         Its items are playlists like "Top 100: Global" and "Top 100: USA".
         If you've been fetching catalog charts using MusicDataRequest in the past, you no longer need to, as MusicKit will do the work for you, with pagination support built into the collection of items.
         In 2021, we introduced groundbreaking audio experiences with true multidimensional sound and clarity: Spatial Audio with support for Dolby Atmos.
         This immersive experience is already available for thousands of songs, and now you can access this data.
         MusicKit exposes which audio resources are available for any song or album through Audio Variants, so now, you can relay this information to others.
         Examples of audio variants are the previously mentioned Spatial Audio with Dolby Atmos, Lossless Audio, and much more.
        We are also exposing a new boolean property alongside audio variants, is Apple Digital Master, which is the highest quality master supported.
         Since this metadata is exposed at the item level, audio variants are perfect for a detail view, allowing you to achieve UI like this.
         Here we have a detail view of an album.
         And here, we can see the appropriate badges based on the audio variants property mentioned earlier, letting users know what audio quality they can expect.
         In this case, spatial audio and lossless audio are available for this specific album.
         Now let's see how we can write code to achieve this.
         Loading audio variants are like loading any other extended attribute.
         Take an existing album or song, in this case an album, and use the with method to load the audioVariants extended attribute.
         Now your detailedAlbum has the audioVariants property populated.
         Here we can see the audio variants property, which is an array whose element is an AudioVariant.
         With these values, you can indicate in your UI the available audio resources for that particular element, just like we saw earlier.
         Now, this is great, but you may want to show these audio badges on more than just top level or detail views.
         That's why we're also taking it one step further and exposing the active audio variant for the music player.
         Accessing the active audio variant allows for a visual indication of the quality of audio for the currently playing item, such as Dolby Atmos in this view.
         And the MusicKit player API automatically chooses the correct audio quality based on user settings and network conditions.
        To access the active trait from the player, first, we access the ApplicationMusicPlayer's playback state in an observed object.
         We can then access the active audioVariant directly from the playback state Now, we simply check the audioVariant property to see if it's dolbyAtmos, and add additional UI if it is.
         Because the playback state is an observed object, this view will automatically update whenever the currently playing item changes, making sure your view is always up-to-date.
         Now that we've gone over some catalog additions, let's dive into fetching personalized content.
         Personalized content is data specific to a subscriber, providing a unique and tailored experience for every user in your app.
         Normally, personalized content requires special authentications and user tokens, but in the MusicKit framework, we've made this all automatic so you don't have to deal with any of the hassle.
         The personalized content we're bringing to developers is access to recently played items and personal recommendations.
         Recently played content is a valuable piece of data for a person's music consumption experience.
         It allows for quick and easy access to music items you know they enjoy.
         And when listening to new music, it allows people to later go back and refer to their history.
         To fetch recently played containers like albums, playlists, and stations, you can create a recently played container request.
         Note that if you play a song from a playlist or album, the container type will be retrieved.
         In the response, you will find recently played music items, which offer convenience accessors for the title, subtitle, and artwork.
         You can also fetch recently played items of more specific types, like songs or stations.
         Here, we create a recently played request, specifying the Song type through the generic parameter, indicated by the angle brackets.
         Our response now only contains the songs that we have played.
         Now, onto personal recommendations.
         Personal recommendations let your app experience feel more intimate and engaging as they are generated based off the user's library and listening history.
         Recommendations are nicely organized by themes, resulting in groupings by genres, artists, collections like "Made for You," and more.
         To fetch personal recommendations, simply create a personal recommendations request.
         The response is a collection of recommendations.
         When we log the first recommendation, we can see that this particular element represents the "Made for You" recommendation.
         Recommendations have an ID, title, and nextRefreshDate.
         The nextRefreshDate represents the date time for when this recommendation should be refreshed for the most up-to-date suggestions.
         The playlists property contains all of the playlists that are made for me.
         Let's take a look at another example of a recommendation.
         Here we'll print out the second element of the recommendations response.
         I listen to a ton of alternative music, and this recommendation contains a mix of different types, in this case, Albums and Playlists.
         Those are grouped in a single collection of items, which are ordered by relevancy, much like top results for catalog search.
         Now, let's take it a step further and talk about how you can create even more relevant experiences around music by incorporating content from your user's library into your app.
         This year, MusicKit allows your app to fetch items from the library with two types of requests: the library request and the library sectioned request, search for content in the user's library, and load extended attributes and relationships specifically from the library.
         Before we see the technical details, let's see how we can use library content to enhance your app.
         I've been working on a fitness app called Music Marathon that will track your outdoor runs.
         By incorporating MusicKit in the project, we allow people to play music directly through the app instead of context switching between the Apple Music app and this one.
         Let's start a new workout and look for music content.
        Here we see some recommended playlists retrieved from the personal recommendations request, to give people quick access to playlists we think they'll love.
         Going to the library tab, we can see it's an empty view.
         It would be great to be able to see all of my personal playlists, so let's write that feature.
         I already have some UI set up to handle the basics of this view, and now I want to load the playlists from my library.
         First, I'll make library request.
        ..Specifying playlist in the generic parameter to indicate that we want the playlists from the user's library.
        And I'll store it in a local variable I'll name "request.
        " Next I'll take this request and call the response function.
        This method is an async throwing method, so let's add the try and await keywords.
         and once again store it in a response variable.
        Then, I'll update the state object to receive this response.
        Now all that's left to do is update the list so we can see the playlists in my UI.
         I'll iterate through the items in the response using a ForEach.
        ..And retrieve each playlist in the MusicItemCollection.
        Now that we have the playlists, I'll pass them into a PlaylistCell I've already made.
        Now if we re-run.
        ..And navigate back to the app, we can see all of my personal playlists in the library.
         Now, I can choose to listen to personal recommendations, anything from the Apple Music catalog, and my own personal library.
         Now that we've seen how easy it is to access library content, let's look at what else the library request can do.
         The music library request is a powerful API to fetch items from the user's library.
         On iOS, unlike other requests to fetch content from the music catalog, MusicLibraryRequest will not actually load data from the network.
         Instead, it will load items from the copy of the user's library that is stored on device.
         The basics of this request only require you to specify which music item type is desired.
         This item type is passed through the generic parameter of the MusicLibraryRequest.
         You can apply a variety of filters and sort options on the request in order to finely tune your call to match your requirements.
         This request is also capable of fetching already downloaded content, supporting a fully offline experience.
         Let's start with the simple, base request, the same request we wrote in the Music Marathon app, but this time, ask for the Albums in the library.
         The album type is specified through the generic parameter.
         To perform the request, call the response function.
         Looking at the output, we have a MusicLibraryResponse, where its items are a MusicItemCollection of all the albums found within the user's music library.
         Here we notice that these Albums are the same Album structure that you would get from one of our various catalog requests and have the same capabilities.
         Whereas in this example we are fetching every album in the library, we know there are scenarios where you only want a specific subset of albums.
         That's why MusicLibraryRequest also enables you to be more specific about what items you want to fetch from the library.
         Let's take the same request we wrote before and add a filter.
         Here, we want to load all albums where the isCompilation property is equal to true.
         When you call filter method, Xcode's autocompletion will only offer specific key paths that are supported for the type of item you are requesting.
         Now, the response only has albums which are compilations.
         But that's not all the power the MusicLibraryRequest has to offer.
         You can chain multiple filters, giving you a more refined request with each addition.
         What if we wanted all of the compilations of a particular genre? We can add another filter to the request.
         For example, here we have an instance of Genre named "Dance.
        " You can filter by the genre's relationship to restrict the results to only include compilations that contain this specific genre.
         Now our response only contains dance compilations.
         How about only including dance compilations that are already downloaded? To do that, just set the includeOnlyDownloadedContent to true on the request.
         And that's it.
         The response is the same MusicLibraryResponse, but the items now only contain elements that are downloaded.
         As you can see, the music library request is very powerful and unlocks new capabilities that weren't possible with a custom MusicDataRequest.
         But MusicKit offers even more options to fetch data from the user's library.
         Meet the Library Sectioned Request.
         The sectioned request is able to fetch items grouped by sections.
         As a result, the sectioned request takes in two distinct generic parameters.
         The first representing the section type, and the second, the item type.
         The library sectioned request supports the same capabilities as the regular library request, such as a variety of filter and sort methods which you can apply to either the sections or the items.
         Here's how you can fetch all albums sectioned by their genres using the library sectioned request.
         The sectioned Response holds a property named "sections" where each element corresponds to the first generic parameter of the request, Genre in this case.
         Each genre not only exposes its own attributes, but it also contains a collection of albums, accessible via the items property.
         Those items correspond to the second generic argument.
         Here, the highlight shows albums whose genre is Alternative.
         And as mentioned before, the capabilities of filtering and sorting are also available for this sectioned request.
         Let's say we want the same albums, sectioned by genres, but the albums sorted by their artist's name.
         We add a sort filter.
         By specifying the artistName keyPath on Albums and saying that we want these to be ascending, we're sorting the response.
         Notice that the method is sortItems as we are specifying the sorting to be applied to the items and not the sections.
         Had we wanted to specify the sections, a set of filterSections and sortSection methods are available.
         Let's take a look at the new response.
        We can now see that our albums are ordered alphabetically by artist name instead of by their titles.
         Both the library request and library sectioned request are extremely powerful, but you might also want to complement your music search UI by adding search results from the user's library.
         So we've added a new structured request which operates almost identically to catalog search, but instead of loading results from the catalog, it finds relevant items in the user's library.
         Just like its catalog counterpart, the library search request only requires a search term and an array of types.
         Now that we've seen the different ways to retrieve items from the user's library, what about loading extended attributes and relationships? As you may know, the initial release of MusicKit introduced the with method, loading these properties from Apple Music API in a straightforward way.
         This year, we're augmenting the current with method to also take in a preferred source parameter.
         This preferred source indicates where to load data from, for extended attributes and relationships that are available in both the Apple Music catalog and the user's library.
         And for the properties that only live in either the catalog or the library, they will still fetched regardless of the preferred source to make sure nothing is ignored.
         In addition, you can use this functionality no matter where the initial item came from, whether it be a catalog request, a library request, or elsewhere.
         It all just works.
        Here we have the known way of receiving a relationship of a music item.
         We're loading the tracks of an album, and when we display the output, we can see all of the tracks for that album.
         However, with the new addition of the preferredSource property, we can specify that we would like to fetch this relationship from the library.
         Now our output only contains the tracks of the album found in the library.
         With the various ways you can now fetch items from the user's library, it only makes sense to allow users to be able to interact with their library directly through MusicKit.
         Let's jump back into my sample app, Music Marathon, to see some of the capabilities the library offers.
         As I'm working out, I want to browse through some of my personal recommendations.
        As I look through the tracks, I realize that one of these songs would be perfect for my workout playlist.
         If hold down one of these cells, a contextual menu pops up, allowing me to add this song to a playlist.
         When we press it, a pop-up of all of my playlists appear again.
         Let's write code to add the selected track to whichever playlist I pick.
         I've already piped the selected item to our AddToPlaylistCell cell, so all we have to do is access the MusicLibrary through the shared instance.
        We'll call the "add" method, specifying our selected track and which playlist we want to add to.
        This method is also an async throwing function, so we add once again the try and await keywords.
        Lastly, we'll dismiss the picker by setting the isShowingPlaylistPicker binding variable to false.
        Now if we re-run and add a track to a playlist and select one of our playlists, we should expect to see this item added.
         Navigating back to the library tab within the app, we can see the song is now added to our workout playlist.
         And that's how simple it is to add an item to a playlist.
         Let's look at some of the other functionality the library offers.
         The various other ways to interact with the library are adding content to the library, creating playlists, and editing playlists' metadata and track list.
         Adding content to the user's music library allows people to find specific songs or albums in the library tab of the Apple Music app, as well as synchronizes across all devices when "Sync Library" is turned on in Settings.
         Providing this functionality directly in your app saves people from context switching between the Apple Music app and yours, so they can stay engaged in the content you're providing.
         Also, by integrating adding to the library along with the newly introduced library requests, your app can immediately benefit from these results, giving users easy access to content they love.
         Even with this powerful service, you may still want to craft specific musical experiences.
         So this year, we're bringing playlist creation and editing to MusicKit.
         You can now create playlists on behalf of your users.
         We're also allowing items, such as songs or even whole albums, to be added to any eligible playlist in the user's library.
         Creating playlists are fantastic for grouping content that people love or fitting any mood your app wants to set.
         And by adding content to existing playlists, you allow for the various music discovery tools MusicKit offers to directly affect people.
         You can now also edit playlists that you've created, being able to edit the track list and metadata to make sure everything is just as you want it.
         And those are the ways you can interact with users' libraries from within your app.
         To wrap up, MusicKit received some major upgrades this year.
         Easily incorporate our catalog enhancements for new types, properties, and search augmentations to your existing apps for an even better experience.
        Integrate library content and functionality to unlock brand-new capabilities and let users be in control of their experience.
        And using MusicKit can enhance multiple different types of apps.
         Fitness apps, games, social media apps, mapping apps, and more can all benefit from playing or sharing music.
         To go even further, make sure to check out some related sessions.
         Dive deeper into Swift and learn about the new additions to the language to get the most out of MusicKit and other Apple Frameworks.
         Check out the MusicKit session from 2021 to learn how to set up your app to use the framework, initiate playback, and present subscription offers.
         And if you're interested in integrating with Apple Music on Android or the web, we have another session that goes over how to use Apple Music API directly.
        I hope you enjoyed our session, and make sure to stay updated and engaged through our developer forums.
         Thank you for watching, and enjoy WWDC 2022.

        """
    }

    var japanese: String {
        """
        こんにちは、そしてWWDCへようこそ。
         私はデイビッドと申しますが、MusicKitでより多くのコンテンツを探索する方法についてお話したいと思います。
         MusicKitフレームワークは2021年に発表され、Swiftでネイティブに音楽にアクセスし、再生するためのAPIセットを提供します。
         このフレームワークにより、あなたのアプリはApple Musicと簡単に統合でき、Apple Musicの全カタログにアクセスできるようになります。
         今日は、MusicKitに施された主な機能強化についてお話したいと思います。
         まず、新しい音楽アイテムタイプ、新しいリクエスト、新しいメタデータなど、Apple Musicのカタログをさらに活用するための追加機能から始めます。
        その後、パーソナライズされたコンテンツをフェッチして、それぞれのユーザーに合わせた体験を提供する方法について説明します。
         次は、Apple Musicのカタログの先にあるものです。
         今年は、ユーザーのライブラリの音楽を含めることで、あなたのアプリをまったく新しいレベルに引き上げることができます。
         最後に、ライブラリやプレイリストへのアイテムの追加、プレイリストの作成と編集など、ライブラリとアクティブにやり取りする方法について説明します。
         カタログコンテンツの追加に飛び込もう
         MusicKit の最初のリリースでは、Songs、Albums、Playlists などのコアタイプを含む、音楽の新しいモデル レイヤーを導入しました。
         今年は、2つの新しいタイプを追加して、MusicKitで新しい音楽を発見することをより簡単にします。CuratorとRadio Showです。
        それ以外にも、MusicKitでは、カタログを検索するための優れたUIを構築したり、トップチャートにアクセスして最も人気のある曲やアルバムなどを取得したり、Dolby Atmos搭載Spatial Audioなどのより高品質なオーディオメタデータなどの新しい属性を取得することができるようになりました。
        まずは、音楽発見のための素晴らしいリソースである、キュレーターとラジオ番組から始めましょう。
         ここでは、キュレーターの一例であるNikeを取り上げます。
         他のキュレーターの例としては、ShazamとBeats by Dr. Dreがあります。
         Dreです。
         ここでは、このキュレーターが作成したすべてのプレイリストを簡単に見つけることができます。
         この機能により、人々は自分が好きそうなプレイリストに素早くアクセスし、新しい曲を見つけたり、昔のお気に入りを再確認したりすることができるのです。
         次に、より技術的な詳細について説明します。
        キュレーターには、さまざまな属性があります。
         この新しいキュレータータイプの主要な属性には、name、url、artwork、kind があります。
         kind 属性は enum で、"editorial" または "external" のどちらかを選択できます。これは、指定されたキュレータが Apple のキュレータであるか、サードパーティのキュレータであるかを示します。
        キュレーターは、そのキュレーターが作成したプレイリストを表示するプレイリストの関係も持っており、先ほどの音楽発見の概念にまさに合致しています。
        次に、ラジオ番組タイプです。
         New Music Daily by Zane Lowe」や「Pop Hits Radio by Brooke Reese」などのラジオ番組も、経験豊富な専門家を通じて新しい音楽を発見する方法のひとつです。
         キュレータータイプと同様に、ラジオ番組もプレイリストの関係を持っており、ラジオ番組が取り上げる音楽を見つけることができます。
         この2つの新しいタイプはプレイリストのリレーションシップを保持するように、プレイリストのタイプにも「Curator」と「RadioShow」という2つの新しいリレーションシップを公開し、プレイリストがあれば、どのエンティティがそのプレイリストを生成したか簡単に構造を取得できるという逆のロジックを実現しています。
        MusicKit では、さまざまなタイプのコンテンツをカタログから検索することができますが、今回、キュレーターやラジオ番組といった新しいアイテム・タイプのサポートを追加しました。
         その結果、優れたUIを構築することはますます難しくなっています。
         そこで今年は、トップ実績と提案によって、より簡単にUIを構築できるようにしました。
         これらの機能強化がUIにもたらす効用について見ていきましょう。
         タイピングしてコンテンツを検索するとき、音楽に関連する強力なオートコンプリートをサポートしたいと思うかもしれません。
         そこで、人々が到達しようとしているであろう言葉を提供する、サジェストが活躍します。
         さらに一歩進んで、人々が探しているものにすばやくアクセスできるように、上位の検索結果を表示することもできます。
         最良の結果を得るためには、アイテムの種類は気にせず、関連性を重視するのもよいでしょう。
         これがトップリザルトの威力です。
         では、これを実装するとどのようになるのか、まずはトップリザルトから見ていきましょう。
         ここでは、検索語と表示させたいアイテムの種類を指定して、カタログ検索リクエストを作成する既存の方法を示しています。
         レスポンスには、要求されたタイプによって分類されたコレクションが含まれ、つまりタイプ別の結果を示す複数のリストが表示されます。
         これは素晴らしいことですが、私たちは、タイプにとらわれない、最も関連性の高い結果の単一のリストを公開したいと考えています。
         そして、この情報を要求するのは、1行を追加するのと同じくらい簡単です。
         ここでは、リクエストの includeTopResults プロパティを true に設定し、レスポンスに新しいプロパティが入力されます。
         この新しいプロパティは topResults という名前で、要求されたタイプのアイテムが含まれています。
         以下は、print 文の出力のようすです。
         返された上位の結果は、1つのコレクションに含まれる曲、アーティスト、アルバムが混在し、関連性によって並べられていることがわかります。
         では、サジェスチョンを使って、より早く検索先にたどり着けるようにする方法を紹介します。
         文字列を指定してサジェスト要求を作成するだけです。
         responseを呼び出すと、suggestionsレスポンスが返ってきます。
         このレスポンスにはSuggestionsの配列が含まれています。
         そして各サジェストには、あなたのUIに適した表示用語と、検索用語が含まれています。
         人々がサジェストを選択すると、検索用語で検索要求を実行することによって、対応する結果を取得することができます。
        カタログチャートは、最も人気のある曲の最新情報を得るのに最適な方法です。
         MusicKitは、トレンドの曲を確認するためのさまざまな種類のチャートを提供します。
         提供されているチャートの種類は、最も再生されている音楽に対応するトップソングやトップアルバムなどのトップチャート、シティチャート、デイリートップ100などです。
         また、特定のジャンルでフィルタリングされたチャートを要求することもできます。
         コードによるこれらのチャートの取得は、非常に簡単です。
         カタログチャートリクエストは、カタログ検索リクエストですでに使われている確立されたパターンを踏襲しています。
         まず、チャート要求を初期化します。
         そして、欲しいチャートの種類を指定します。
         デフォルトでは、最も再生されたコンテンツを取得しますが、デイリーグローバルトップチャートやシティトップチャートも含めることができます。
         最後に、チャートに含ませたい種類を指定するだけです。
         これで完了です。
         レスポンスの最初のプレイリスト チャートにアクセスすると、デイリー グローバル トップ チャートを表す MusicCatalogChart が得られます。
         そのアイテムは、"Top 100: Global" や "Top 100: USA" といったプレイリストです。
         これまでMusicDataRequestを使ってカタログチャートを取得していた場合、アイテムのコレクションに組み込まれたページネーションサポートにより、MusicKitがその作業を行うので、もはやその必要はありません。
         2021年には、真の多次元的なサウンドと透明感を備えた画期的なオーディオ体験を導入しました。Dolby AtmosをサポートしたSpatial Audioです。
         この没入感のある体験は、すでに何千もの楽曲で利用可能であり、このデータにアクセスできるようになりました。
         MusicKitは、Audio Variantsを通じて、どの曲やアルバムでどのオーディオリソースが利用できるかを公開するので、この情報を他の人に伝えることができるようになりました。
         Audio Variantsの例としては、以前紹介したDolby AtmosによるSpatial Audio、Lossless Audioなどがあります。
        また、オーディオバリアントと一緒に、Apple Digital Masterという新しいブール値のプロパティも公開しています。
         このメタデータはアイテムレベルで公開されるため、オーディオバリアントは詳細表示に最適で、次のようなUIを実現できます。
         ここにアルバムの詳細ビューがあります。
         ここでは、前述のオーディオバリアントプロパティに基づく適切なバッジが表示され、期待されるオーディオ品質をユーザーに知らせています。
         この場合、この特定のアルバムでは、空間オーディオとロスレス・オーディオが利用可能です。
         では、これを実現するためのコードをどのように書けばよいかを見てみましょう。
         オーディオバリアントの読み込みは、他の拡張属性の読み込みと同じです。
         既存のアルバムまたは曲（この場合はアルバム）を取り、withメソッドを使ってaudioVariants拡張属性をロードします。
         これで、detailedAlbum に audioVariants プロパティが設定されました。
         ここで、audioVariants プロパティは、AudioVariant を要素とする配列であることがわかります。
         これらの値によって、先ほど見たように、特定の要素で利用可能なオーディオリソースを UI に表示することができます。
         さて、これは素晴らしいことですが、これらのオーディオバッジをトップレベルや詳細ビュー以外にも表示したいと思うかもしれません。
         そこで、もう一歩踏み込んで、ミュージックプレイヤーのアクティブオーディオバリアントを公開します。
         アクティブオーディオバリアントにアクセスすると、このビューではDolby Atmosのように、現在再生中のアイテムのオーディオの品質を視覚的に示すことができるようになります。
         そして、MusicKitプレーヤーAPIは、ユーザー設定とネットワーク条件に基づいて、正しいオーディオ品質を自動的に選択します。
        プレーヤーからアクティブな特性にアクセスするために、まず、観察されたオブジェクトでApplicationMusicPlayerの再生状態にアクセスします。
         次に、再生状態から直接 active audioVariant にアクセスします。ここで、単に audioVariant プロパティをチェックして、dolbyAtmos であるかどうかを確認し、そうであれば追加の UI を追加します。
         再生状態は観測されたオブジェクトなので、現在再生中のアイテムが変更されるたびにこのビューは自動的に更新され、ビューが常に最新であることを確認できます。
         さて、カタログの追加について説明しましたが、次にパーソナライズドコンテンツの取得について説明します。
         パーソナライズドコンテンツは、購読者に固有のデータで、アプリのすべてのユーザーにユニークでカスタマイズされた体験を提供します。
         通常、パーソナライズドコンテンツには特別な認証とユーザトークンが必要ですが、MusicKitフレームワークでは、これをすべて自動化し、面倒な作業を一切行わずに済むようにしています。
         私たちがデベロッパーに提供するパーソナライズドコンテンツは、最近再生したアイテムやパーソナルレコメンデーションへのアクセスです。
         最近再生したコンテンツは、その人の音楽消費体験にとって貴重なデータの一部です。
         相手が楽しんでいることがわかる音楽アイテムに、素早く簡単にアクセスすることができるのです。
         また、新しい音楽を聴くときに、後で履歴をさかのぼって参照することができます。
         アルバム、プレイリスト、ステーションなど、最近再生したコンテナを取得するには、最近再生したコンテナのリクエストを作成します。
         プレイリストやアルバムから曲を再生すると、コンテナタイプが取得されることに注意してください。
         レスポンスには、最近再生した音楽アイテムがあり、タイトル、サブタイトル、アートワークの便利なアクセッサが提供されます。
         また、曲や放送局など、より具体的なタイプの最近再生されたアイテムを取得することもできます。
         ここでは、最近再生した曲のリクエストを作成し、角括弧で示した generic パラメータで Song タイプを指定します。
         このレスポンスには、再生した曲だけが含まれています。
         次に、パーソナル・レコメンデーションについて説明します。
         パーソナル・レコメンデーションは、ユーザーのライブラリと聴取履歴に基づいて生成されるため、アプリの体験をより親密で魅力的なものにしてくれます。
         レコメンデーションは、ジャンル、アーティスト、"Made for You "などのコレクションによってグループ化され、テーマごとにきれいに整理されています。
         パーソナルレコメンデーションを取得するには、パーソナルレコメンデーションリクエストを作成するだけです。
         レスポンスは、レコメンデーションの集合体です。
         最初のレコメンデーションを記録すると、この特定の要素が「Made for You」レコメンデーションを表していることがわかる。
         レコメンデーションには、ID、タイトル、およびnextRefreshDateがあります。
         nextRefreshDateは、このレコメンデーションが最新のレコメンデーションに更新される日付を表します。
         playlistsプロパティには、自分用に作成されたすべてのプレイリストが含まれています。
         別のレコメンデーションの例を見てみましょう。
         ここでは、recommendationsレスポンスの2番目の要素をプリントアウトします。
         私はたくさんのオルタナティブミュージックを聴きますが、このレコメンデーションには、さまざまなタイプ（この場合はアルバムとプレイリスト）が混在しています。
         これらは、カタログ検索のトップ結果のように、関連性によって並べられた、ひとつのアイテムのコレクションにまとめられています。
         さて、さらに一歩進んで、ユーザーのライブラリのコンテンツをアプリに取り込むことで、音楽にまつわるさらに関連性の高い体験を実現する方法についてお話ししましょう。
         今年のMusicKitでは、ライブラリリクエストとライブラリセクションドリクエストという2種類のリクエストでライブラリからアイテムを取得し、ユーザーのライブラリ内のコンテンツを検索し、拡張属性と関係をライブラリから特別に読み込むことがアプリでできるようになりました。
         技術的な詳細を見る前に、ライブラリのコンテンツを使用してアプリを拡張する方法を見てみましょう。
         私は、屋外でのランニングを記録する「Music Marathon」というフィットネス・アプリを制作しています。
         このプロジェクトにMusicKitを組み込むことで、Apple Musicアプリとこのアプリをコンテキストで切り替える代わりに、アプリを通じて直接音楽を再生できるようにしました。
         新しいワークアウトを開始し、音楽のコンテンツを探してみましょう。
        ここでは、個人的なおすすめリクエストから取得したおすすめのプレイリストをいくつか表示しています。
         ライブラリタブに移動すると、何も表示されていないことがわかります。
         自分のプレイリストをすべて見ることができれば最高なので、その機能を書いてみましょう。
         このビューの基本を処理するためのUIはすでにセットアップされているので、今度は自分のライブラリからプレイリストをロードしたいと思います。
         まず、ライブラリのリクエストをします。
        ...一般パラメータにplaylistを指定し、ユーザーのライブラリからプレイリストを取得することを示します。
        そして、それをローカル変数に格納します。名前は「request.
        " 次に、このリクエストを受け取り、レスポンス関数を呼び出します。
        このメソッドは非同期スローメソッドなので、tryとawaitキーワードを追加しましょう。
         そして、再びresponse変数に格納する。
        そして、このレスポンスを受け取るために、ステート・オブジェクトを更新します。
        あとはリストを更新して、プレイリストをUIで見ることができるようにするだけです。
         レスポンスに含まれる項目をForEachで反復処理します。
        そして、MusicItemCollection にある各プレイリストを取得します。
        プレイリストを取得したので、それらをすでに作成したPlaylistCellに渡します。
        さて、再実行すると......。
        アプリに戻ると、ライブラリにあるすべての個人用プレイリストを見ることができます。
         これで、個人的なおすすめ曲、Apple Musicのカタログにあるもの、そして自分の個人的なライブラリを選んで聴くことができるようになりました。
         さて、ライブラリのコンテンツへのアクセスがいかに簡単かを見てきましたが、次にライブラリリクエストで他に何ができるかを見てみましょう。
         ミュージックライブラリのリクエストは、ユーザーのライブラリからアイテムを取得するための強力なAPIです。
         iOS では、ミュージックカタログからコンテンツを取得する他のリクエストとは異なり、MusicLibraryRequest は実際にネットワークからデータをロードしません。
         その代わり、デバイスに保存されているユーザーのライブラリのコピーからアイテムをロードします。
         このリクエストの基本は、希望する音楽アイテムの種類を指定することのみです。
         このアイテムタイプは、MusicLibraryRequest の generic パラメータに渡されます。
         要求に合わせて呼び出しを細かく調整するために、リクエストにさまざまなフィルタとソートオプションを適用することができます。
         このリクエストは、すでにダウンロードされたコンテンツを取得することも可能で、完全なオフライン体験をサポートします。
         シンプルで基本的なリクエストから始めましょう。Music Marathon アプリで書いたのと同じリクエストですが、今回はライブラリのアルバムを要求します。
         アルバムの種類は、genericパラメータで指定します。
         リクエストを実行するには、レスポンス関数を呼び出します。
         出力されたMusicLibraryResponseには、ユーザーのミュージックライブラリにある全てのアルバムのMusicItemCollectionが含まれます。
         ここで、これらのアルバムは、様々なカタログ要求から得られるのと同じアルバム構造であり、同じ機能を持っていることに気づきます。
         この例では、ライブラリ内のすべてのアルバムを取得していますが、特定のアルバムのサブセットだけが必要なシナリオがあることも知っています。
         そのため、MusicLibraryRequest では、ライブラリから取得したいアイテムをより具体的に指定することができます。
         先ほど書いたリクエストに、フィルタを追加してみましょう。
         ここでは、isCompilationプロパティがtrueに等しいすべてのアルバムをロードすることを望みます。
         filterメソッドを呼び出すと、Xcodeのオートコンプリートは、要求しているアイテムのタイプに対応している特定のキーパスだけを提供します。
         今、応答には、コンパイルされているアルバムだけがあります。
         しかし、MusicLibraryRequestが提供するパワーは、これだけではありません。
         複数のフィルタを連結して、追加するたびに、より洗練されたリクエストを提供することができます。
         ある特定のジャンルのコンピレーションがすべて欲しいとしたらどうでしょう？リクエストに別のフィルタを追加することができます。
         たとえば、ここに "Dance" というジャンルのインスタンスがあります。
        " ジャンルの関係でフィルタリングして、この特定のジャンルを含むコンピレーションだけを結果に含めるように制限することができます。
         これで、応答にはダンスのコンピレーションだけが含まれるようになりました。
         すでにダウンロードされたダンス系コンピレーションだけを含めるのはどうでしょうか。これを行うには、リクエストのincludeOnlyDownloadedContentをtrueに設定するだけです。
         それでおしまいです。
         レスポンスは同じMusicLibraryResponseですが、アイテムにはダウンロード済みの要素のみが含まれるようになりました。
         このように、ミュージックライブラリのリクエストは非常に強力で、カスタムのMusicDataRequestでは不可能だった新しい機能が解放されます。
         しかし、MusicKitはユーザーのライブラリからデータをフェッチするために、さらに多くのオプションを提供します。
         ライブラリセクションドリクエストを紹介します。
         セクション化されたリクエストは、セクションでグループ化されたアイテムをフェッチすることができます。
         その結果、sectionedリクエストは2つの異なる一般的なパラメータを取ります。
         1 つはセクションのタイプ、もう 1 つはアイテムのタイプです。
         ライブラリセクション付きリクエストは、通常のライブラリリクエストと同じ機能をサポートします。たとえば、セクションまたはアイテムのいずれかに適用できるさまざまなフィルタやソートメソッドなどです。
         以下は、ライブラリセクション化リクエストを使用して、ジャンル別にセクション化されたすべてのアルバムを取得する方法です。
         セクション化されたレスポンスは「sections」という名前のプロパティを持ち、各要素はリクエストの最初の一般パラメータ（この場合はジャンル）に対応します。
         各ジャンルはそれ自身の属性を公開するだけでなく、アルバムのコレクションも含んでおり、items プロパティを通じてアクセスできます。
         これらのアイテムは、2 番目の一般的な引数に対応します。
         ここでは、ジャンルが Alternative であるアルバムをハイライト表示しています。
         また、前述のように、フィルタリングとソートの機能は、このセクション化されたリクエストでも利用可能です。
         例えば、同じアルバムをジャンル別に分類し、アーティスト名でソートして表示する場合を考えてみましょう。
         この場合、ソートフィルターを追加します。
         AlbumsのkeyPathにartistNameを指定し、これらを昇順にしたいと言うことで、レスポンスをソートしています。
         メソッドが sortItems であることに注意してください。これは、セクションではなくアイテムに適用されるソートを指定しているからです。
         セクションを指定したい場合は、filterSections と sortSection メソッドを使用できます。
         新しいレスポンスを見てみましょう。
        アルバムがタイトル順ではなく、アーティスト名のアルファベット順に並んでいることがわかります。
         ライブラリリクエストとライブラリセクション付きリクエストはどちらも非常に強力ですが、ユーザーのライブラリから検索結果を追加して音楽検索のUIを補完したい場合もあるでしょう。
         そこで、カタログ検索とほとんど同じように動作する新しい構造化リクエストを追加しましたが、カタログから結果をロードする代わりに、ユーザーのライブラリから関連する項目を見つけます。
         カタログ検索と同じように、ライブラリ検索リクエストは検索語とタイプの配列だけを必要とします。
         さて、ユーザーのライブラリからアイテムを取得するさまざまな方法について見てきましたが、拡張属性とリレーションシップのロードについてはどうでしょうか。ご存知のように、MusicKit の初期リリースでは with メソッドを導入し、Apple Music API からこれらのプロパティを簡単にロードできるようにしました。
         今年は、現在のwithメソッドを拡張して、preferred sourceパラメータも取り込むようにします。
         この優先ソースは、Apple Musicカタログとユーザーのライブラリの両方で利用可能な拡張属性とリレーションシップのデータを、どこからロードするかを示します。
         また、カタログとライブラリのどちらかにしか存在しないプロパティについては、何も無視されないように、優先ソースに関係なくフェッチされます。
         さらに、この機能は、最初のアイテムがカタログのリクエスト、ライブラリのリクエストなど、どこから来たかに関係なく使うことができます。
         すべてがうまくいくのです。
        ここでは、音楽アイテムのリレーションシップを受信する既知の方法を示します。
         あるアルバムのトラックをロードし、出力を表示すると、そのアルバムのすべてのトラックを見ることができます。
         しかし、新たに preferredSource プロパティが追加され、ライブラリからこのリレーションシップを取得するように指定することができるようになりました。
         これで、出力には、ライブラリで見つかったアルバムのトラックのみが含まれるようになりました。
         ユーザーのライブラリからアイテムを取得するさまざまな方法があるため、ユーザーがMusicKitを通じて自分のライブラリを直接操作できるようにすることは理にかなっています。
         サンプルアプリ「Music Marathon」に戻って、ライブラリが提供する機能のいくつかを見てみましょう。
         ワークアウト中に、個人的なおすすめ曲をブラウズしてみたいと思います。
        楽曲を眺めていると、この曲はワークアウトのプレイリストにぴったりだと気づきました。
         このセルの一つを長押しすると、コンテクストメニューがポップアップし、この曲をプレイリストに追加することができます。
         これを押すと、すべてのプレイリストのポップアップが再び表示されます。
         選択した曲をどのプレイリストに追加するか、コードを書いてみましょう。
         選択した曲は、すでにAddToPlaylistCellに転送されていますので、あとは共有インスタンスからMusicLibraryにアクセスするだけです。
        選択したトラックと、どのプレイリストに追加するかを指定して、"add "メソッドを呼び出します。
        このメソッドも非同期のスローイング関数なので、もう一度tryとawaitキーワードを追加しています。
        最後に、バインディング変数 isShowingPlaylistPicker を false に設定することで、ピッカーを停止します。
        これで、再実行してプレイリストにトラックを追加し、プレイリストの 1 つを選択すると、このアイテムが追加されていることが確認できるはずです。
         アプリ内のライブラリタブに戻ると、この曲がワークアウトプレイリストに追加されていることがわかります。
         このように、プレイリストへのアイテムの追加はとても簡単です。
         次に、ライブラリーの他の機能を見てみましょう。
         ライブラリにコンテンツを追加する、プレイリストを作成する、プレイリストのメタデータやトラックリストを編集する、など様々な方法でライブラリを操作することができます。
         ユーザーのミュージックライブラリにコンテンツを追加すると、Apple Musicアプリのライブラリタブで特定の曲やアルバムを探すことができるようになり、また、設定で「ライブラリを同期」をオンにすると、すべてのデバイス間で同期されます。
         この機能をアプリに直接提供することで、ユーザーはApple Musicアプリとアプリを切り替える手間が省け、提供するコンテンツに没頭することができます。
         また、新しく導入されたライブラリリクエストと一緒にライブラリへの追加を統合することで、あなたのアプリはすぐにこれらの結果の恩恵を受け、ユーザーが好きなコンテンツに簡単にアクセスできるようになります。
         このような強力なサービスであっても、特定の音楽体験を作りたいと思うことはあるでしょう。
         そこで今年、私たちはプレイリストの作成と編集をMusicKitに導入しました。
         ユーザーの代わりにプレイリストを作成できるようになりました。
         また、ユーザーのライブラリにあるプレイリストに、曲やアルバム全体などのアイテムを追加できるようになりました。
         プレイリストの作成は、ユーザーが好きなコンテンツや、アプリが設定したいムードに合ったコンテンツをグループ化するのに最適な方法です。
         また、既存のプレイリストにコンテンツを追加することで、MusicKitが提供するさまざまな音楽発見ツールが人々に直接影響を与えるようになります。
         作成したプレイリストの編集も可能になり、トラックリストやメタデータを編集して、すべてが思い通りになるようにすることができます。
         そしてこれらは、あなたのアプリの中からユーザーのライブラリと対話できる方法なのです。
         最後に、MusicKitは今年、いくつかの大きなアップグレードを受けました。
         新しいタイプ、プロパティ、検索機能の拡張など、カタログの機能強化を既存のアプリに簡単に組み込んで、さらに優れたエクスペリエンスを実現しましょう。
        ライブラリのコンテンツと機能を統合して、まったく新しい機能を引き出し、ユーザーが自分の体験をコントロールできるようにします。
        また、MusicKitを使うことで、複数の異なるタイプのアプリケーションを強化することができます。
         フィットネスアプリケーション、ゲーム、ソーシャルメディアアプリケーション、地図アプリケーションなど、すべてのアプリケーションで音楽の再生や共有のメリットを享受できます。
         さらに詳しく知りたい方は、関連するセッションもぜひご覧ください。
         Swiftをより深く理解し、MusicKitやその他のApple Frameworksを最大限に活用するために、言語に追加された新しい機能について学びましょう。
         2021年のMusicKitセッションをチェックして、フレームワークを使用するためのアプリケーションのセットアップ方法、再生の開始方法、サブスクリプションオファーの提示方法について学んでください。
          また、AndroidやWeb上でApple Musicと連携することに興味がある方は、Apple Music APIを直接使用する方法について説明する別のセッションもあります。
         私たちのセッションを楽しんでいただければ幸いです。また、私たちの開発者フォーラムを通じて、最新情報を入手し、参加してください。
          WWDC2022をお楽しみに。
        """
    }
}
